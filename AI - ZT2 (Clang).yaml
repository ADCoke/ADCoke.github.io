###############################################################################

Input:
Assume that the input is a set of facts specified by the following predicates:
adjacent(X, Y): country X is adjacent to country Y
eu(X): country X is a member of the European Union
candidate(X): country X is a candidate member
euro(X): country X uses the Euro
schengen(X): country X belongs to the Schengen area
Note: The name of a state is given by a string constant.

Task:
Write an ASP program that computes all Schengen countries that share a border with a Non-Schengen country. For each such county C, derive an atom outerBorder(C).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#show outerBorder/1.
outerBorder(C) :- schengen(C), adjacent(C, D), not schengen(D).

###############################################################################

Input:
Assume that the input is given by following predicates:

eagle(X) specifies that X is an eagle
penguin(X) specifies that X is a penguin
Task:
Write an ASP program to represent the following knowledge:
eagles are birds
penguins are birds
birds can fly, except for penguins, who cannot fly
Use the following predicates:

bird(X) specifies that X is a bird
fly(X) specifies that X can fly
-fly(X) specifies that X cannot fly
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#show bird/1. #show fly/1. #show -fly/1. #show penguin/1. #show eagle/1.
bird(X; Y) :- eagle(X), penguin(Y).
fly(X) :- eagle(X).
-fly(X) :- penguin(X).

###############################################################################

Input:
Assume that the input is a set of facts specified by the following predicates:
adjacent(X, Y): country X is adjacent to country Y
eu(X): country X is a member of the European Union
candidate(X): country X is a candidate member
euro(X): country X uses the Euro
schengen(X): country X belongs to the Schengen area
Note: The name of a state is given by a string constant.

Task:
Write an ASP program that computes all EU countries that currently share a border with a Non-Schengen country, but would not share such a border anymore after all current EU and EU candidate countries join the Schengen area. For each such county C, derive an atom result(C).

(In this example "outer border" is strictly defined by EU-membership: borders with countries like VaticanCity or Switzerland count as outer borders, although they are often not called that way!)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#show result/1.
hasSchengenBorder(X) :- adjacent(X, Y), eu(X), not schengen(Y).
fakeSchengenArea(X; Y; Z) :- schengen(X), eu(Y), candidate(Z).
fakeSchengenBorder(X) :- eu(X), adjacent(X, Y), not fakeSchengenArea(Y).
result(X) :- hasSchengenBorder(X), not fakeSchengenBorder(X).

###############################################################################

Input:
Assume that the input is a set of facts specified by the following predicates:

- childOf(X, Y): X is a child of Y
- female(X): X is female
- male(X): X is male
Task:
Write an ASP program that derives atoms over the following predicates:

cousin(X, Y): whenever X is a cousin of Y
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#show cousin/2.
sibling(X, Y) :- childOf(X, A), childOf(Y, A), X != Y.
cousin(X, Y) :- childOf(X, A), childOf(Y, B), sibling(A, B).

###############################################################################

Input:
Assume that the input is a set of facts specified by the following predicates:
state(X): X is a US state
adjacent(X, Y): state X is adjacent to state Y
Note: The name of a state is given by a constant starting with lower-case letter (without quotes). If the state name consists of multiple words, they are concatenated without blanks and each new word (except the first one) starts with an upper-case letter. Examples: california, florida, newYork, northDakota, rhodeIsland, districtOfColumbia

Task:
Write an ASP program that computes in predicate result(.) the US states that are adjacent to at least five other states.

You can (but do not have to) use helper predicates, but make sure to keep the #show directives in the answer box!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#show result/1.
result(X) :- adjacent(X, A), adjacent(X, B), adjacent(X, C), adjacent(X, D), adjacent(X, E),
A != B, A != C, A != D, A != E, B != C, B != D, B != E, C != D, C != E, D != E.

###############################################################################

Input:
The input defines the connections between two stations in the public transport system in Vienna. It is a set of facts of form

conn(From, To, Type, Line).

where From and To are quoted station names, Type declares the type of transportation (bus, tram, train or metro; all without quotes), and Line specifies the quoted name of the line.

Examples:

conn("Vorgartenstraße","Donauinsel",metro,"U1").
conn("Siedlung Sonnheim","Eisstoßgasse",bus,"93A").
conn("Aumannplatz","Weinhauser Gasse",tram,"41").
conn("Laa an der Thaya Bahnhof","Kottingneusiedl Bahnhof",train,"S2").

Moreover, assume that a fact of form start(S)., where S is a station is, is given.

Task:
Write an ASP program that computes all nodes reachable from S by metro with arbitrary many line changes but at most three stops (excluding S but including the destination). The result is to be encoded using atoms of form reachable(.).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#show reachable/1.
reachable(X):- conn(S,X,metro,A), start(S).
reachable(Y):- conn(S,X,metro,A), conn(X,Y,metro,B), start(S).
reachable(Z):- conn(S,X,metro,A), conn(X,Y,metro,B), conn(Y,Z,metro,C), start(S).

###############################################################################

Input:
Assume that the input is a set of facts specified by the following predicates:

childOf(X, Y): X is a child of Y
female(X): X is female
male(X): X is male
Task:
Write an ASP program that derives atoms over the following predicates:
father(X, Y): whenever X is the father of Y
mother(X, Y): whenever X is the mother of Y
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#show father/2. #show mother/2.
father(X, Y) :- childOf(Y, X), male(X).
mother(X, Y) :- childOf(Y, X), female(X).

###############################################################################

Input:
Assume that the input is a set of facts specified by the following predicates:
state(X): X is a US state
adjacent(X, Y): state X is adjacent to state Y
Note: The name of a state is given by a constant starting with lower-case letter (without quotes). If the state name consists of multiple words, they are concatenated without blanks and each new word (except the first one) starts with an upper-case letter. Examples: california, florida, newYork, northDakota, rhodeIsland, districtOfColumbia

Task:
Write an ASP program that computes in predicate result(X) the US states that can be reached from missouri over exactly one other state (but not directly).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#show result/1.
result(X) :- state(X), adjacent(missouri, Y), adjacent(X, Y), not adjacent(missouri, X), X != missouri, Y != missouri.

###############################################################################

Input:
The input defines a graph as follows:

node(X) defines that X ist a node
arc(X, Y) defines that there is a (directed) arc from X to Y
Task:
Write an ASP program that computes all nodes X that have both outgoing and incoming arcs. The result is to be encoded using atoms of form output(.).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#show output/1.
output(X) :- node(X), arc(X, Y), arc(Z, X).

###############################################################################

Input:
The input defines the connections between two stations in the public transport system in Vienna. It is a set of facts of form

conn(From, To, Type, Line).

where From and To are quoted station names, Type declares the type of transportation (bus, tram, train or metro; all without quotes), and Line specifies the quoted name of the line.

Examples:

conn("Vorgartenstraße","Donauinsel",metro,"U1").
conn("Siedlung Sonnheim","Eisstoßgasse",bus,"93A").
conn("Aumannplatz","Weinhauser Gasse",tram,"41").
conn("Laa an der Thaya Bahnhof","Kottingneusiedl Bahnhof",train,"S2").

Moreover, assume that a fact of form start(S)., where S is a station is, is given.

Task:
Write an ASP program that computes all nodes reachable from S by metro only (but with an arbitrary number of changes). The result is to be encoded using atoms of form reachable(.).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#show reachable/1.
reachable(X) :- conn(X, A, metro, L), reachable(A).
reachable(X) :- start(X).